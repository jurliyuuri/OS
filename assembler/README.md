この記事は[言語実装 Advent Calendar 2017](https://qiita.com/advent-calendar/2017/lang_dev)の18日目の記事です。

# 異世界で使われている設定のアセンブリ言語をHaskellで実装する


[「異世界転生したけど日本語が通じなかった」](https://kakuyomu.jp/works/1177354054883808252)とかに出てくる異世界ファイクレオネで使われている設定のアセンブリ言語2003lkを、Haskellを使って実装した話を書いていきます。

## 構成

## 言語仕様を軽く解説
詳しい説明は[設定一覧](http://jurliyuuri.com/OS/settings.html)に書いてあるので、以下言語実装の説明に必要最低限な要素だけ解説する。

### `'c'i`と`'i'c`
### ラベル
### `kue`と`xok`
`kue`<sup>[1](#myfootnote1)</sup>がラベルをexportする擬似命令で、`xok`<sup>[2](#myfootnote2)</sup>がラベルをimportする擬似命令である。現状、ファイル分割でできるのはラベルの共有だけなので、逆に`kue`のないファイルの先頭をエントリーポイントとする仕様となっている。


## パーサ

`a=(1+2)*3` みたいな再帰的な構文はないので、わざわざParsecを使うのもオーバーキルかなぁという考えのもと自前実装。コードは[Parse.hs](https://github.com/jurliyuuri/OS/blob/master/assembler/Parse.hs#L127)。とはいえ単純な仕様なので、一気に字句解析・構文解析・意味解析して`Either ParseError ParsedFile`を吐く設計。`ParsedFile`型は
```
type ParsedFile = ([(Instruction, [Label])],([Label],[Label]))
```
と定義されている。最初の`[(Instruction, [Label])]`は「命令、およびそれに付随しているラベル」のリストであり、もう片方の`([Label],[Label])`は`kue`の一覧と`xok`の一覧を格納している。

### 字句解析
Haskellには`words`とかいう便利な関数があるので、それを使ってスペースで区切るだけである。ただし、2003lkの仕様上`+`と`@`の前後にはスペースを要求しないので、そこは`concatMap`を上手く使って処理している。

`words`処理をした後は、`beautify`という関数で「A `@`」または「A `+` B `@`」というパターンを見つけ、一つの『トークン』としてまとめている。不適切な位置に出てきた `+` や `@` はこの段階で弾いている。

### 構文解析・意味解析
`beautify`されたトークン列は`toInstructions`に渡される。`toInstructions`の処理の本体は`toI`関数である。
リストの先頭に命令があるので、それに従って引数を取得していく。なお、2003lkは命令からオペランド数が一意に定まる仕様となっているので、命令と命令の間に改行を置く必要はない。逆に、構文解析していく際にも行については一切考慮することなく先頭から読んでいっている。

それぞれの命令がどのような引数を取るのかも予め分かっているため、このタイミングで「即値への代入」などの誤った命令も弾いている。



## 脚注
<a name="myfootnote1">1</a>:リパライン語kinunsares「公開する」由来  
<a name="myfootnote2">2</a>:リパライン語xokison「別の場所で」由来


