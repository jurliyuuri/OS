<!doctype html>
<html>
<head>
<title>オペコード</title>
<meta charset="UTF-8">
<style>
.comment{color: green;}
.box{border: 1px solid blue; padding: 10px; margin: 10px;}
</style>
</head>
<body>
<h2>1. 設定</h2>
<s> <a href="https://docs.google.com/spreadsheets/d/1AUex8DDU9n5r-q27MD-6_aW5en-vmXZ55ptzm91yV74/edit#gid=0">Google SpreadSheetで作業中</a></s><b>OBSOLETE:: 2017/08/29 23:40時点で既に部分的に無効</b>
<pre>
2017/08/28:
呼び出し規約を確定させる
スタックの掃除をするのは呼び出し側
いじって良いレジスタは4個 (f0 ~ f3)
引数は前からスタックに積む
戻り値は単純型ならレジスタ (f0) でやり取り
</pre>

<h2>2. 実践</h2>
<p>さて、呼び出し規約も決まったことだし色々書いていきますかね。とりあえずフィボナッチ書こう。スタックを管理するのは（ダイスロール）f5ですな。まずはCっぽく。</p>
<pre>
int fib(int a)
{
	register int f0 = a;
	register int f1 = 0; 
	register int f2 = 1;
	register int f3;
	while(f0) {
		f0--;
		f3 = f1 + f2;
		f1 = f2;
		f2 = f3;
	}
	f0 = f1;
	return f0;
}
</pre>
<p>解説</p>
<table>
<tr><td>f0<td>5<td>4<td>4<td>3<td>3<td>2<td>2<td>1<td>1<td>0<td>0<td>5
<tr><td>f1<td>0<td>0<td>1<td>1<td>1<td>1<td>2<td>2<td>3<td>3<td>5<td>
<tr><td>f2<td>1<td>1<td>1<td>1<td>2<td>2<td>3<td>3<td>5<td>5<td>8<td>
<tr><td>f3<td> <td>1<td> <td>2<td> <td>3<td> <td>5<td> <td>8<td> <td>
</table>
<p>x86風に書いてみる</p>
<pre>
	MOV f0 [ESP+4]
	MOV f1 0
	MOV f2 1
a:	EQU f0 0
	J_C b <span class="comment">;フラグを見てジャンプ</span>
	ADD f0 -1
	MOV f3 f1
	ADD f3 f2
	MOV f1 f2
	MOV f2 f3
	JMP a
b:	MOV f0 f1
	JMP [ESP]
	ADD ESP 4

</pre>

<p>リパに翻訳</p>
<pre>
	krz f0 [f5+4]
	krz f1 0
	krz f2 1
is:	sie f0 0
	J_C ka <span class="comment">; どうしよう</span>
	ata f0 -1
	krz f3 f1
	ata f3 f2
	krz f1 f2
	krz f2 f3
	krz xx is
ka:	krz f0 f1
	krz xx [f5]
	ata f5 4
</pre>

<p>というか、自明に「xxをいじる = ジャンプ」なので、ジャンプ命令を作ってそれを<code>krz xx abcde</code>と書いても良い設定にすればよい。ファイクレオネにはWPのおかげで既にワープ・瞬間移動・縮地法の類がありそうなので、それを流用するのが自然な気がする。</p>

<h2>3. 設定part2</h2>
<p>2で出てきた設定を（明示・暗黙共に）まとめる。</p>
<ul>
<li>スタックを管理するのはf5</li>
<li>xxレジスタには「次に実行する命令のアドレス」が格納されている。CPUは<ruby><rb>針</rb><rt>プログラムカウンタ</rt></ruby>を持っていて、ひたすら「xxを1増やす→針の指す命令を実行する→xxの指す位置に針を動かす」を繰り返す、と。</li>
<li>無条件ジャンプ・条件ジャンプは共に、内部構造としては「xxを上書きする命令」である。ただ、<code>krz</code>命令では代用できない（「フラグを見てkrzするか決める」という命令はないため）ので、別命令として作り<code>krz xx iska</code>もジャンプ命令に翻訳、という感じ？いや待て、『「フラグを見てkrzするか決める」という命令はない』など誰が言った？あってもええやん！（後世が投機実行の実装に苦しむ図）（でもオモロイやん採用）</li>
<li>ということで「フラグを見て代入するかどうか決める」命令を考えよう</li>
</ul>

<h2>4. Fafs falira sashimiと打ち合わせ</h2>
<p>「フラグを見て代入するかどうか決める」命令をどうすべきか迷ったので、<a href="redefine_comparison.txt">打ち合わせを行った</a>。その結果、比較演算子系統のニーモニックが全部作り直しになった。</p>

<h3>4-1. 結果</h3>
<div class="box">
<p>基本構文：</p>
<pre>
fi <u>第一オペランド</u> <u>第二オペランド</u> <u>比較表現</u>
malkrz <u>レジスタ</u> <u>値</u>
</pre>
</div>
<div class="box">
<p>例：</p>
<pre>
fi f0 f1 lloler
malkrz f2 f3
</pre>
</div>
<p>この構文は、上記の例に即するなら、Fi f0 es f1 le loler, mal krantairzarth f2'c f3'i. 「f0がf1よりも大きいならば、f3をf2にコピーする」というリパライン語表現にちょうど対応する。</p>

<h3>4-2. 念のため補足</h3>

<p>もちろん、実際の処理としては、【<code>fi ~ lloler</code>命令は「第一オペランドが第二オペランドよりも大きいならばフラグを立てる」命令であり、<code>malkrz</code>命令が「フラグが立っているときにのみ第一オペランドに第二オペランドの値を代入する」命令である】ということであり、自然なリパライン語として読めるかどうかということは正しいアセンブリ言語になるかどうかとは当然別物である。</p>

<p>その証拠に、リパライン語では上記の文をFi f0 es f1 le loler, krantairzarth f2'c f3'i.というふうにmalという語を抜かして表現しても意味は変わらないが、</p>
<pre>
fi f0 f1 lloler
krz f2 f3
</pre>
<p>は当然「f0がf1よりも大きいならばフラグを立てる。さてそれはともかくf3をf2にコピーする」という別の意味の命令群になる。リパラオネ人がこの仕様に苦しむのは、まるで現世でC系統の言語を習い始めた人が<code>if(a = 0)</code>とか<code>if(a == 0||1)</code>とか書いてしまうようなものである。</p>


<h2>5. 実践part2</h2>
<p>ということで、4.に基づき前述のフィボナッチを修正していこう。</p>
<pre>
	krz f0 [f5+4]
	krz f1 0
	krz f2 1
is:	fi f0 0 cloler <span class="comment">; ce loler</span> 
	malkrz xx ka 
	ata f0 -1
	krz f3 f1
	ata f3 f2
	krz f1 f2
	krz f2 f3
	krz xx is
ka:	krz f0 f1
	krz xx [f5]
	ata f5 4
</pre>

<p>よし、これで初めての関数である。やったー。</p>

<p>しかし、<code>cloler</code>がやっぱりちょっと長い気がするなぁ（他が短すぎるだけともいう）</p>
</body>
</html>
