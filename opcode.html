<!doctype html>
<html>
<head>
<title>オペコード</title>
<meta charset="UTF-8">
<style>
.comment{color: green;}
.box{border: 1px solid blue; padding: 10px; margin: 10px;}
</style>
</head>
<body>
<h2>1. 設定</h2>
<s> <a href="https://docs.google.com/spreadsheets/d/1AUex8DDU9n5r-q27MD-6_aW5en-vmXZ55ptzm91yV74/edit#gid=0">Google SpreadSheetで作業中</a></s><b>OBSOLETE:: 2017/08/29 23:40時点で既に部分的に無効</b>
<pre>
2017/08/28:
呼び出し規約を確定させる
スタックの掃除をするのは呼び出し側
いじって良いレジスタは4個 (f0 ~ f3)
引数は前からスタックに積む
戻り値は単純型ならレジスタ (f0) でやり取り
</pre>

<h2>2. 実践</h2>
<p>さて、呼び出し規約も決まったことだし色々書いていきますかね。とりあえずフィボナッチ書こう。スタックを管理するのは（ダイスロール）f5ですな。まずはCっぽく。</p>
<pre>
int fib(int a)
{
	register int f0 = a;
	register int f1 = 0; 
	register int f2 = 1;
	register int f3;
	while(f0) {
		f0--;
		f3 = f1 + f2;
		f1 = f2;
		f2 = f3;
	}
	f0 = f1;
	return f0;
}
</pre>
<p>解説</p>
<table>
<tr><td>f0<td>5<td>4<td>4<td>3<td>3<td>2<td>2<td>1<td>1<td>0<td>0<td>5
<tr><td>f1<td>0<td>0<td>1<td>1<td>1<td>1<td>2<td>2<td>3<td>3<td>5<td>
<tr><td>f2<td>1<td>1<td>1<td>1<td>2<td>2<td>3<td>3<td>5<td>5<td>8<td>
<tr><td>f3<td> <td>1<td> <td>2<td> <td>3<td> <td>5<td> <td>8<td> <td>
</table>
<p>x86風に書いてみる</p>
<pre>
	MOV f0 [ESP+4]
	MOV f1 0
	MOV f2 1
a:	EQU f0 0
	J_C b <span class="comment">;フラグを見てジャンプ</span>
	ADD f0 -1
	MOV f3 f1
	ADD f3 f2
	MOV f1 f2
	MOV f2 f3
	JMP a
b:	MOV f0 f1
	JMP [ESP]
	ADD ESP 4

</pre>

<p>リパに翻訳</p>
<pre>
	krz f0 [f5+4]
	krz f1 0
	krz f2 1
is:	sie f0 0
	J_C ka <span class="comment">; どうしよう</span>
	ata f0 -1
	krz f3 f1
	ata f3 f2
	krz f1 f2
	krz f2 f3
	krz xx is
ka:	krz f0 f1
	krz xx [f5]
	ata f5 4
</pre>

<p>というか、自明に「xxをいじる = ジャンプ」なので、ジャンプ命令を作ってそれを<code>krz xx abcde</code>と書いても良い設定にすればよい。ファイクレオネにはWPのおかげで既にワープ・瞬間移動・縮地法の類がありそうなので、それを流用するのが自然な気がする。</p>

<h2>3. 設定part2</h2>
<p>2で出てきた設定を（明示・暗黙共に）まとめる。</p>
<ul>
<li>スタックを管理するのはf5</li>
<li>xxレジスタには「次に実行する命令のアドレス」が格納されている。CPUは<ruby><rb>針</rb><rt>プログラムカウンタ</rt></ruby>を持っていて、ひたすら「<a id="geasz"><s>xxを1増やす</s> <b><a href="#bgsd">嘘です。</a></b></a>→針の指す命令を実行する→xxの指す位置に針を動かす」を繰り返す、と。</li>
<li>無条件ジャンプ・条件ジャンプは共に、内部構造としては「xxを上書きする命令」である。ただ、<code>krz</code>命令では代用できない（「フラグを見てkrzするか決める」という命令はないため）ので、別命令として作り<code>krz xx iska</code>もジャンプ命令に翻訳、という感じ？いや待て、『「フラグを見てkrzするか決める」という命令はない』など誰が言った？あってもええやん！（後世が投機実行の実装に苦しむ図）（でもオモロイやん採用）</li>
<li>ということで「フラグを見て代入するかどうか決める」命令を考えよう</li>
</ul>

<h2>4. Fafs falira sashimiと打ち合わせ</h2>
<p>「フラグを見て代入するかどうか決める」命令をどうすべきか迷ったので、<a href="redefine_comparison.txt">打ち合わせを行った</a>。その結果、比較演算子系統のニーモニックが全部作り直しになった。</p>

<h3>4-1. 結果</h3>
<div class="box">
<p>基本構文：</p>
<pre>
fi <u>第一オペランド</u> <u>第二オペランド</u> <u>比較表現</u>
malkrz <u>レジスタ</u> <u>値</u>
</pre>
</div>
<div class="box">
<p>例：</p>
<pre>
fi f0 f1 lloler
malkrz f2 f3
</pre>
</div>
<p>この構文は、上記の例に即するなら、Fi f0 es f1 le loler, mal krantairzarth f2'c f3'i. 「f0がf1よりも大きいならば、f3をf2にコピーする」というリパライン語表現にちょうど対応する。</p>

<h3>4-2. 念のため補足</h3>

<p>もちろん、実際の処理としては、【<code>fi ~ lloler</code>命令は「第一オペランドが第二オペランドよりも大きいならばフラグを立てる」命令であり、<code>malkrz</code>命令が「フラグが立っているときにのみ第一オペランドに第二オペランドの値を代入する」命令である】ということであり、自然なリパライン語として読めるかどうかということは正しいアセンブリ言語になるかどうかとは当然別物である。</p>

<p>その証拠に、リパライン語では上記の文をFi f0 es f1 le loler, krantairzarth f2'c f3'i.というふうにmalという語を抜かして表現しても意味は変わらないが、</p>
<pre>
fi f0 f1 lloler
krz f2 f3
</pre>
<p>は当然「f0がf1よりも大きいならばフラグを立てる。さてそれはともかくf3をf2にコピーする」という別の意味の命令群になる。リパラオネ人がこの仕様に苦しむのは、まるで現世でC系統の言語を習い始めた人が<code>if(a = 0)</code>とか<code>if(a == 0||1)</code>とか書いてしまうようなものである。</p>


<h2>5. 実践part2</h2>
<p>ということで、4.に基づき前述のフィボナッチを修正していこう。</p>
<pre>
	krz f0 [f5+4]
	krz f1 0
	krz f2 1
is:	fi f0 0 cloler <span class="comment">; ce loler</span> 
	malkrz xx ka 
	ata f0 -1
	krz f3 f1
	ata f3 f2
	krz f1 f2
	krz f2 f3
	krz xx is
ka:	krz f0 f1
	krz xx [f5]
	ata f5 4
</pre>

<p>よし、これで初めての関数である。やったー。</p>

<p>しかし、<code>cloler</code>がやっぱりちょっと長い気がするなぁ（他が短すぎるだけともいう）</p>

<p>さて、じゃあ再帰フィボナッチも実装しましょうかね。まずはC</p>

<pre>
int fib2(int a)
{
	register int f0 = a;
	register int f1;
	register int f2;

	if(f0 < 2) {
		goto fin;
	}

	f1 = f0;
	f1--;
	f0 = fib2(f1);
	f2 = f0;
	f1--;
	f0 = fib2(f1);
	f2 += f0;
	f0 = f2;

	fin:
	return f0;
}
</pre>

<p>まずはx86もどき混じりで翻訳。</p>

<pre>
fib2:	krz f0 [f5+4]
	fi f0 2 xyloler
	malkrz xx iska
	krz f1 f0
	ata f1 -1
	PUSH f1
	CALL fib2
	POP f1 <span class="comment">;関数呼び出しでf1が破壊されるので修復</span>
	krz f2 f0
	ata f1 -1
	PUSH f2
	PUSH f1
	CALL fib2
	POP
	POP f2
	ata f2 f0
	krz f0 f2
iska:	RET
</pre>

<p>次に、関数呼び出しとスタック操作について整理しよう。</p>

<div class="box">
<p>スタックにiskaをプッシュする</p>
<pre>
	ata f5 -4	<span class="comment">; f5を持ち上げて</span>
	krz [f5] iska	<span class="comment">; 積む</span>
</pre>
</div>

<div class="box">
<p>スタックをポップしてiskaに代入</p>
<pre>
	krz iska [f5]	<span class="comment">; スタックの値を代入</span>
	ata f5 4	<span class="comment">; f5を下げる</span>
</pre>
</div>

<div class="box">
<p>return f0;</p>
<pre>
	krz xx [f5]	<span class="comment">; リターンアドレスに飛んで</span>
	ata f5 4	<span class="comment">; スタックからリターンアドレスを削除</span>
</pre>
</div>

<div class="box" style="border:1px solid red">
<p>f0 = func();</p>
<pre>
	<span class="comment">; えっと、</span>
	ata f5 -4	<span class="comment">; スタックにリターンアドレスを</span>
	krz [f5] xx	<span class="comment">; 積む</span>
	krz xx func	<span class="comment">; 関数のアドレスにジャンプ</span>
	<span class="comment">; でいいのかな？</span>
	<span class="comment">; いいえ。積んだときのxxはkrz xx funcを指しています。よってこれでは無限ループします</span>
	<span class="comment">; さてどうしよう。</span>
	<span class="comment">; 普通ならここで素直にCALLのニーモニックを作ればいいんだろうが、2003'd ferlesylの作者は全部をxxへの操作としたがる人だ</span>
	<span class="comment">; そうだ、2つのkrzを1回で行う命令を作ればいいんだ</span>
	<span class="comment">; 名前はqa stevypo krzの略でqskrzとでもすればいいか。</span>
	<span class="comment">; krz fi stの後にkrz st irをすることをqskrz fi st irと書けることにすればよい。</span>
	<span class="comment">; 実際処理としてよくありそうなやつだし。汎用性あるし採用していいでしょ</span>
	<span class="comment">; ということで仕切り直し</span>
</pre>
</div>


<div class="box">
<p>f0 = func();</p>
<pre>
	ata f5 -4	<span class="comment">; スタックを準備</span>
	qskrz [f5] xx func	<span class="comment">; リターンアドレスを積んで、同一命令で関数のアドレスにジャンプ</span>
</pre>
</div>

<p>CALLの実装書いてて気づいたけど、<a id="bgsd">前に<a href="#geasz">xxを1増やす</a>って書いたの嘘やん。</a>固定長でもないし1byteでもないもん。単純に「次の命令を指すところにxxが移動する」ですな。</p>

<p>さて、ここまでやったところで翻訳。</p>
<pre>
fib2:	krz f0 [f5+4]
	fi f0 2 xyloler
	malkrz xx iska
	krz f1 f0
	ata f1 -1
	ata f5 -4
	krz [f5] f1
	ata f5 -4
	qskrz [f5] xx fib2
	krz f1 [f5]
	ata f5 4
	krz f2 f0
	ata f1 -1
	ata f5 -4	
	krz [f5] f2
	ata f5 -4	
	krz [f5] f1
	ata f5 -4
	qskrz [f5] xx fib2
	krz f2 [f5+4]
	ata f5 8
	ata f2 f0
	krz f0 f2
iska:	krz xx [f5]
	ata f5 4
</pre>

<h2>6. 課題</h2>
<p>まず、5に出てきた新規設定をまとめる。</p>
<ul>
<li>ce lolerはcloler、xy lolerはxyloler</li>	
<li>krz fi stの後にkrz st irをすることをqskrz fi st irと書けることにする。2で出てきた非再帰フィボナッチでも使うことのできる汎用性の高い命令。</li>	
<li>CPUは<ruby><rb>針</rb><rt>プログラムカウンタ</rt></ruby>を持っていて、ひたすら「次の命令を指すところにxxを移動させる→針の指す命令を実行する→xxの指す位置に針を動かす」を繰り返す</li>
</ul>
<p>この2番目と3番目を組み合わせると、なんと関数呼び出しが実行できるのである。</p>
<p>また、slackで出てきた課題について述べる。</p>
<ul>
<li>「オペランドの順番どうする？」
</li><li>「[fistir]というx86由来の表記法をどうにかしたい」
</li><li>「色んな名前空間が衝突しているぞ。ラベルとニーモニックと関数名とレジスタ名と。」
</li><li>「他が3文字4文字の中でllolerって長いのでは」
</li></ul>

<p>待てよ？qskrz fi st irをCでいう「fi = st; st = ir;」ではなく「tmp = st; st = ir; fi = tmp;」であると再定義してやれば、上記のコードに一切の変更を与えずかつfiとirが同一であるときXCHGとして使えるのでは！？これは楽しいぞ。とりあえず命令名を変えなくては。Fafs氏に訊こう。</p>
<img src="qskrz.png" height="100"/>
</body>
</html>
