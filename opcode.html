<!doctype html>
<html>
<head>
<title>オペコードなどについて考察する</title>
<meta charset="UTF-8">
<link rel="stylesheet" href="common.css">
</head>
<body>
<h1>オペコードなどについて考察する</h1>

<p>以下のは雑記・考察ログです。仕様だけ知りたい人は<a href="settings.html">設定一覧</a>をお読みください。ソースコードの例としては<a href="fib_non_recursive.jurli.html">非再帰フィボナッチ</a>と<a href="fib_recursive.jurli.html">再帰フィボナッチ</a>と<a href="./qsort.jurli.html">quicksort</a>があります。</p>

<h2>1. 設定</h2>
<s> <a href="https://docs.google.com/spreadsheets/d/1AUex8DDU9n5r-q27MD-6_aW5en-vmXZ55ptzm91yV74/edit#gid=0">Google SpreadSheetで作業中</a></s><b>OBSOLETE:: 2017/08/29 23:40時点で既に部分的に無効</b>
<pre>
2017/08/28:
呼び出し規約を確定させる
スタックの掃除をするのは呼び出し側
いじって良いレジスタは4個 (f0 ~ f3)
引数は前からスタックに積む
戻り値は単純型ならレジスタ (f0) でやり取り
</pre>

<h2>2. 実践</h2>
<p>さて、呼び出し規約も決まったことだし色々書いていきますかね。とりあえずフィボナッチ書こう。スタックを管理するのは（ダイスロール）f5ですな。まずはCっぽく。</p>
<pre>
int fib(int a)
{
	register int f0 = a;
	register int f1 = 0; 
	register int f2 = 1;
	register int f3;
	while(f0) {
		f0--;
		f3 = f1 + f2;
		f1 = f2;
		f2 = f3;
	}
	f0 = f1;
	return f0;
}
</pre>
<p>解説</p>
<table>
<tr><td>f0<td>5<td>4<td>4<td>3<td>3<td>2<td>2<td>1<td>1<td>0<td>0<td>5
<tr><td>f1<td>0<td>0<td>1<td>1<td>1<td>1<td>2<td>2<td>3<td>3<td>5<td>
<tr><td>f2<td>1<td>1<td>1<td>1<td>2<td>2<td>3<td>3<td>5<td>5<td>8<td>
<tr><td>f3<td> <td>1<td> <td>2<td> <td>3<td> <td>5<td> <td>8<td> <td>
</table>
<p>x86風に書いてみる</p>
<pre>
	MOV f0 [ESP+4]
	MOV f1 0
	MOV f2 1
a:	EQU f0 0
	J_C b <span class="comment">;フラグを見てジャンプ</span>
	ADD f0 -1
	MOV f3 f1
	ADD f3 f2
	MOV f1 f2
	MOV f2 f3
	JMP a
b:	MOV f0 f1
	JMP [ESP]
	ADD ESP 4

</pre>

<p>リパに翻訳</p>
<pre>
	krz f0 [f5+4]
	krz f1 0
	krz f2 1
is:	sie f0 0
	J_C ka <span class="comment">; どうしよう</span>
	ata f0 -1
	krz f3 f1
	ata f3 f2
	krz f1 f2
	krz f2 f3
	krz xx is
ka:	krz f0 f1
	krz xx [f5]
	ata f5 4
</pre>

<p>というか、自明に「xxをいじる = ジャンプ」なので、ジャンプ命令を作ってそれを<code>krz xx abcde</code>と書いても良い設定にすればよい。ファイクレオネにはWPのおかげで既にワープ・瞬間移動・縮地法の類がありそうなので、それを流用するのが自然な気がする。</p>

<h2>3. 設定part2</h2>
<p>2で出てきた設定を（明示・暗黙共に）まとめる。</p>
<ul>
<li>スタックを管理するのはf5</li>
<li>xxレジスタには「次に実行する命令のアドレス」が格納されている。CPUは<ruby><rb>針</rb><rt>プログラムカウンタ</rt></ruby>を持っていて、ひたすら「<a id="geasz"><s>xxを1増やす</s> <b><a href="#bgsd">嘘です。</a></b></a>→針の指す命令を実行する→xxの指す位置に針を動かす」を繰り返す、と。</li>
<li>無条件ジャンプ・条件ジャンプは共に、内部構造としては「xxを上書きする命令」である。ただ、<code>krz</code>命令では代用できない（「フラグを見てkrzするか決める」という命令はないため）ので、別命令として作り<code>krz xx iska</code>もジャンプ命令に翻訳、という感じ？いや待て、『「フラグを見てkrzするか決める」という命令はない』など誰が言った？あってもええやん！（後世が投機実行の実装に苦しむ図）（でもオモロイやん採用）</li>
<li>ということで「フラグを見て代入するかどうか決める」命令を考えよう</li>
</ul>

<h2>4. Fafs falira sashimiと打ち合わせ</h2>
<p>「フラグを見て代入するかどうか決める」命令をどうすべきか迷ったので、<a href="redefine_comparison.txt">打ち合わせを行った</a>。その結果、比較演算子系統のニーモニックが全部作り直しになった。</p>

<h3>4-1. 結果</h3>
<div class="box">
<p>基本構文：</p>
<pre>
fi <u>第一オペランド</u> <u>第二オペランド</u> <u>比較表現</u>
malkrz <u>レジスタ</u> <u>値</u>
</pre>
</div>
<div class="box">
<p>例：</p>
<pre>
fi f0 f1 lloler
malkrz f2 f3
</pre>
</div>
<p>この構文は、上記の例に即するなら、Fi f0 es f1 le loler, mal krantairzarth f2'c f3'i. 「f0がf1よりも大きいならば、f3をf2にコピーする」というリパライン語表現にちょうど対応する。</p>

<h3>4-2. 念のため補足</h3>

<p>もちろん、実際の処理としては、【<code>fi ~ lloler</code>命令は「第一オペランドが第二オペランドよりも大きいならばフラグを立てる」命令であり、<code>malkrz</code>命令が「フラグが立っているときにのみ第一オペランドに第二オペランドの値を代入する」命令である】ということであり、自然なリパライン語として読めるかどうかということは正しいアセンブリ言語になるかどうかとは当然別物である。</p>

<p>その証拠に、リパライン語では上記の文をFi f0 es f1 le loler, krantairzarth f2'c f3'i.というふうにmalという語を抜かして表現しても意味は変わらないが、</p>
<pre>
fi f0 f1 lloler
krz f2 f3
</pre>
<p>は当然「f0がf1よりも大きいならばフラグを立てる。さてそれはともかくf3をf2にコピーする」という別の意味の命令群になる。リパラオネ人がこの仕様に苦しむのは、まるで現世でC系統の言語を習い始めた人が<code>if(a = 0)</code>とか<code>if(a == 0||1)</code>とか書いてしまうようなものである。</p>


<h2>5. 実践part2</h2>
<p>ということで、4.に基づき前述のフィボナッチを修正していこう。</p>
<pre>
	krz f0 [f5+4]
	krz f1 0
	krz f2 1
is:	fi f0 0 cloler <span class="comment">; ce loler</span> 
	malkrz xx ka 
	ata f0 -1
	krz f3 f1
	ata f3 f2
	krz f1 f2
	krz f2 f3
	krz xx is
ka:	krz f0 f1
	krz xx [f5]
	ata f5 4
</pre>

<p>よし、これで初めての関数である。やったー。</p>

<p>しかし、<code>cloler</code>がやっぱりちょっと長い気がするなぁ（他が短すぎるだけともいう）</p>

<p>さて、じゃあ再帰フィボナッチも実装しましょうかね。まずはC</p>

<pre>
int fib2(int a)
{
	register int f0 = a;
	register int f1;
	register int f2;

	if(f0 < 2) {
		goto fin;
	}

	f1 = f0;
	f1--;
	f0 = fib2(f1);
	f2 = f0;
	f1--;
	f0 = fib2(f1);
	f2 += f0;
	f0 = f2;

	fin:
	return f0;
}
</pre>

<p>まずはx86もどき混じりで翻訳。</p>

<pre>
fib2:	krz f0 [f5+4]
	fi f0 2 xyloler
	malkrz xx iska
	krz f1 f0
	ata f1 -1
	PUSH f1
	CALL fib2
	POP f1 <span class="comment">;関数呼び出しでf1が破壊されるので修復</span>
	krz f2 f0
	ata f1 -1
	PUSH f2
	PUSH f1
	CALL fib2
	POP
	POP f2
	ata f2 f0
	krz f0 f2
iska:	RET
</pre>

<p>次に、関数呼び出しとスタック操作について整理しよう。</p>

<div class="box">
<p>スタックにiskaをプッシュする</p>
<pre>
	ata f5 -4	<span class="comment">; f5を持ち上げて</span>
	krz [f5] iska	<span class="comment">; 積む</span>
</pre>
</div>

<div class="box">
<p>スタックをポップしてiskaに代入</p>
<pre>
	krz iska [f5]	<span class="comment">; スタックの値を代入</span>
	ata f5 4	<span class="comment">; f5を下げる</span>
</pre>
</div>

<div class="box">
<p>return f0;</p>
<pre>
	krz xx [f5]	<span class="comment">; リターンアドレスに飛んで</span>
	ata f5 4	<span class="comment">; スタックからリターンアドレスを削除</span>
</pre>
</div>

<div class="box" style="border:1px solid red">
<p>f0 = func();</p>
<pre>
	<span class="comment">; えっと、</span>
	ata f5 -4	<span class="comment">; スタックにリターンアドレスを</span>
	krz [f5] xx	<span class="comment">; 積む</span>
	krz xx func	<span class="comment">; 関数のアドレスにジャンプ</span>
	<span class="comment">; でいいのかな？</span>
	<span class="comment">; いいえ。積んだときのxxはkrz xx funcを指しています。よってこれでは無限ループします</span>
	<span class="comment">; さてどうしよう。</span>
	<span class="comment">; 普通ならここで素直にCALLのニーモニックを作ればいいんだろうが、2003'd ferlesylの作者は全部をxxへの操作としたがる人だ</span>
	<span class="comment">; そうだ、2つのkrzを1回で行う命令を作ればいいんだ</span>
	<span class="comment">; 名前はqa stevypo krzの略でqskrzとでもすればいいか。</span>
	<span class="comment">; krz fi stの後にkrz st irをすることをqskrz fi st irと書けることにすればよい。</span>
	<span class="comment">; 実際処理としてよくありそうなやつだし。汎用性あるし採用していいでしょ</span>
	<span class="comment">; ということで仕切り直し</span>
</pre>
</div>


<div class="box">
<p>f0 = func();</p>
<pre>
	ata f5 -4	<span class="comment">; スタックを準備</span>
	qskrz [f5] xx func	<span class="comment">; リターンアドレスを積んで、同一命令で関数のアドレスにジャンプ</span>
</pre>
</div>

<p>CALLの実装書いてて気づいたけど、<a id="bgsd">前に<a href="#geasz">xxを1増やす</a>って書いたの嘘やん。</a>固定長でもないし1byteでもないもん。単純に「次の命令を指すところにxxが移動する」ですな。</p>

<p>さて、ここまでやったところで翻訳。</p>
<pre>
fib2:	krz f0 [f5+4]
	fi f0 2 xyloler
	malkrz xx iska
	krz f1 f0
	ata f1 -1
	ata f5 -4
	krz [f5] f1
	ata f5 -4
	qskrz [f5] xx fib2
	krz f1 [f5]
	ata f5 4
	krz f2 f0
	ata f1 -1
	ata f5 -4	
	krz [f5] f2
	ata f5 -4	
	krz [f5] f1
	ata f5 -4
	qskrz [f5] xx fib2
	krz f2 [f5+4]
	ata f5 8
	ata f2 f0
	krz f0 f2
iska:	krz xx [f5]
	ata f5 4
</pre>

<h2>6. 課題</h2>
<p>まず、5に出てきた新規設定をまとめる。</p>
<ul>
<li>ce lolerはcloler、xy lolerはxyloler</li>	
<li>krz fi stの後にkrz st irをすることをqskrz fi st irと書けることにする。2で出てきた非再帰フィボナッチでも使うことのできる汎用性の高い命令。</li>	
<li>CPUは<ruby><rb>針</rb><rt>プログラムカウンタ</rt></ruby>を持っていて、ひたすら「次の命令を指すところにxxを移動させる→針の指す命令を実行する→xxの指す位置に針を動かす」を繰り返す</li>
</ul>
<p>この2番目と3番目を組み合わせると、なんと関数呼び出しが実行できるのである。</p>
<p>また、slackで出てきた課題について述べる。</p>
<ul>
<li>「オペランドの順番どうする？」
</li><li>「[fistir]というx86由来の表記法をどうにかしたい」
</li><li>「色んな名前空間が衝突しているぞ。ラベルとニーモニックと関数名とレジスタ名と。」
</li><li>「他が3文字4文字の中でllolerって長いのでは」
</li></ul>

<p>待てよ？qskrz fi st irをCでいう「fi = st; st = ir;」ではなく「tmp = st; st = ir; fi = tmp;」であると再定義してやれば、上記のコードに一切の変更を与えずかつfiとirが同一であるときXCHGとして使えるのでは！？これは楽しいぞ。とりあえず命令名を変えなくては。Fafs氏に訊こう。</p>
<img src="qskrz.png" height="100"/>
<hr>
<p>Fafs「qa'd stevypen snidost「二回移動」でqssでいかがでしょうか」</p>
<p>なるほど。まあ片方が移動で片方がコピーなのだが、fi = irのときはswapだしまあよかろう。</p>

<p>llolerについても反応を得た。「lloとでもすればいいのじゃろうなあ」とのこと。同意。</p>
<p>語順についても反応を得た。リパラオネ人は-'i -'cを好むらしい。となると再設計か？めんどい。とは言え、バート人は-'c -'iを好むそうだ。じゃあ「設計者はバート人だったので無意識のうちにV -'c -'iでデザインしていたが、リパラオネ人に-'i -'cの方が自然だと言われた。とはいえ既存のコードを全部修正するのは面倒だったので『ci指定擬似命令』をアセンブリに組み込んだ」という設定にしよう。</p>


<h2>7. 実践part3</h2>
<p>とりあえず、仕様がそれなりに変わったので書き直す。</p>
<div class="box">
<p>非再帰フィボナッチ</p>
<pre>
::'c'i
	krz f0 [f5+4]
	krz f1 0
	krz f2 1
is:	fi f0 0 clo
	malkrz xx ka 
	ata f0 -1
	krz f3 f1
	ata f3 f2
	qss f1 f2 f3
	krz xx is
ka:	krz f0 f1
	krz xx [f5]
	ata f5 4
</pre>
</div>

<div class="box">
<p>再帰フィボナッチ</p>
<pre>
::'c'i
fib2:	krz f0 [f5+4]
	fi f0 2 xylo
	malkrz xx iska
	krz f1 f0
	ata f1 -1
	ata f5 -4
	krz [f5] f1
	ata f5 -4
	qss [f5] xx fib2
	krz f1 [f5]
	ata f5 4
	krz f2 f0
	ata f1 -1
	ata f5 -4	
	krz [f5] f2
	ata f5 -4	
	krz [f5] f1
	ata f5 -4
	qss [f5] xx fib2
	krz f2 [f5+4]
	ata f5 8
	ata f2 f0
	krz f0 f2
iska:	krz xx [f5]
	ata f5 4
</pre>
</div>

<p>角かっこ記法・名前空間の衝突などまだ課題は残るが、とりあえずクイックソートでも書くか。まずはC</p>

<pre>
void quicksort(int* const a, int l, int r)
{
	register int* const f0 = a;
	register int f1 = l; 
	register int f2 = r;
	register int f3;
	if(f1 >= f2) {
		goto fin;
	}
	f3 = f1;
	f3++;
	
panqa:
	if(f3 > r) {
		goto fistir;
	}
	f2 = l;
	f2 = f0[f2];
	if(f0[f3] >= f2) {
		goto iska;
	}
	f1++;
	qss(f0[f3],f0[f1],f0[f3]);
iska: 
	f3++;
	goto panqa;

fistir:
	f2 = l;
	qss(f0[f1],f0[f2],f0[f1]);

	int p = f1;
	quicksort(a,l,p-1);
	quicksort(a,p+1,r);
fin:	
	return;	
}
</pre>

<p>うわぁ（うわぁ）。とりあえずハンドコンパイルせねば</p>

<pre>
::'c'i
ycax:
	krz f2 [f5+4] ; r
	krz f1 [f5+8] ; l
	krz f0 [f5+12] ; a
	fi f1 f2 xolo
	malkrz xx lus
	krz f3 f1
	ata f3 1
panqa:
	fi f3 [f5+4] llo
	malkrz xx fistir
	krz f2 [f5+8]
	krz f2 [f0+f2]
	fi f2 [f0+f3] xtlo
	malkrz xx iska
	ata f1 1
	qss [f0+f3] [f0+f1] [f0+f3]
iska:
	ata f3 1
	krz xx panqa
fistir:
	krz f2 [f5+8]
	qss [f0+f1] [f0+f2] [f0+f1]

	ata f5 -4
	krz [f5] f1 ; push p
	ata f5 -4
	krz [f5] [f5+20] ; push a
	ata f5 -4
	krz [f5] [f5+20] ; push l
	ata f5 -4
	krz f1 [f5+12] ; f1 = p
	ata f1 -1
	krz [f5] f1 ; push p-1
	ata f5 -4
	qss [f5] xx ycax
	ata f5 4 ; aはconstなのでスタックに残っているaを信用してよい
	krz f1 [f5+8] ; f1 = p
	ata f1 1
	krz [f5] f1 ; push p+1
	ata f5 -4
	krz [f5] [f5+20] ; push r
	ata f5 -4
	qss [f5] xx ycax
lus:
	krz xx [f5]
	ata f5 4
</pre>
<p>疲れた。うーん、<code>ata</code>が多いのが気に入らないなぁ</p>

<h2>8. 設定</h2>
<p>書き忘れてた設定を思い出したので書いておく。<a id="nta">nta fistir'c 即値'iはata fistir'c (-即値)'iに翻訳される</a>。上記アセンブリでひたすら<code>ata</code>を使っているのはそういう理由である。</p>
<p>また、符号付きと符号なしを明示的に区別しないほうが楽だよなーとも思っているが、問題は大小比較。今までのコードは正数と負数の比較をしていないのでどちらでもいいんだが、両方用意するとか決めるとかしないとなぁ。</p>

<p>あと、notequalを除いて比較命令が出揃ったので掲載しよう。</p>
<table>
<tr><td>fi ~ xtlo</td><td>fi * es * xut loler</td><td>以下ならフラグを立てる</td></tr>
<tr><td>fi ~ xylo</td><td>fi * es * xy loler</td><td>未満ならフラグを立てる</td></tr>
<tr><td>fi ~ clo</td><td>fi * es * ce loler</td><td>同等ならフラグを立てる</td></tr>
<tr><td>fi ~ xolo</td><td>fi * es * xo loler</td><td>以上ならフラグを立てる</td></tr>
<tr><td>fi ~ llo</td><td>fi * es * le loler</td><td>超過ならフラグを立てる</td></tr>
</table>
<p>そしてこれを<a href="https://docs.google.com/spreadsheets/d/1CmGt_wHdcunhyJv2pp58pwNQwhx4yoZ47rz7LmlvKV4/edit#gid=1597275252">spreadsheet</a>と<a href="https://sites.google.com/site/panqateel/alml">サイト</a>の両方に載せて来た。</p>

<p>あ、あとqssとmalkrzを足してこよう。</p>


<h2>9. 格組の統一</h2>
<p>とりあえず、現状のニーモニック表を貼るとこうなる。</p>
<table border="1" bordercolor="#888" cellspacing="0" class="qq">
<tbody>
<tr>
<td style="width:51px;height:18px">&nbsp;命令</td>
<td style="width:126px;height:18px">&nbsp;語源</td>
<td style="width:60px">&nbsp;x86</td>
<td style="width:287px;height:18px">&nbsp;意味</td>
</tr>
<tr>
<td style="width:71px;height:18px">&nbsp;krz</td>
<td style="width:136px;height:18px">&nbsp;krantairzarth</td>
<td style="width:60px">&nbsp;mov</td>
<td style="width:287px;height:18px">&nbsp;複製</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;ata</td>
<td style="width:116px;height:18px">&nbsp;atakes</td>
<td style="width:60px">&nbsp;add</td>
<td style="width:287px;height:18px">&nbsp;加算</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;nta</td>
<td style="width:116px;height:18px">&nbsp;ny atakes</td>
<td style="width:60px">&nbsp;sub</td>
<td style="width:287px;height:18px">&nbsp;減算</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;stu</td>
<td style="width:116px;height:18px">&nbsp;stusni</td>
<td style="width:60px">&nbsp;mul</td>
<td style="width:287px;height:18px">&nbsp;乗算</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;kak</td>
<td style="width:116px;height:18px">&nbsp;kakites</td>
<td style="width:60px">&nbsp;div</td>
<td style="width:287px;height:18px">&nbsp;除算</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;ada</td>
<td style="width:116px;height:18px">&nbsp;adal</td>
<td style="width:60px">&nbsp;and</td>
<td style="width:287px;height:18px">&nbsp;ビット積</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;ekc</td>
<td style="width:116px;height:18px">&nbsp;ekcan</td>
<td style="width:60px">&nbsp;or</td>
<td style="width:287px;height:18px">&nbsp;ビット和</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;nac</td>
<td style="width:116px;height:18px">&nbsp;nacis</td>
<td style="width:60px">&nbsp;not</td>
<td style="width:287px;height:18px">&nbsp;ビット反転</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;dal</td>
<td style="width:116px;height:18px">&nbsp;daliual</td>
<td style="width:60px">&nbsp;xnor</td>
<td style="width:287px;height:18px">&nbsp;ビットxnor</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;tod</td>
<td style="width:116px;height:18px">&nbsp;tesnokon dusnij</td>
<td style="width:60px">&nbsp;shr</td>
<td style="width:287px;height:18px">&nbsp;右シフト</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;rod</td>
<td style="width:116px;height:18px">&nbsp;restuton dusnij</td>
<td style="width:60px">&nbsp;shl</td>
<td style="width:287px;height:18px">&nbsp;左シフト</td>
</tr>
<tr>
<td>&nbsp;malkrz</td>
<td style="width:100px">&nbsp;mal krantairzarth</td>
<td>
</td>
<td>&nbsp;フラグが立っているときのみ複製する
</td>
</tr>
<tr>
<td>&nbsp;fi ~ xtlo</td>
<td>&nbsp;fi * es * xut loler</td>
<td></td>
<td>&nbsp;以下ならフラグを立てる</td>
</tr>
<tr>
<td>&nbsp;fi ~ xylo</td>
<td>&nbsp;fi * es * xy loler</td>
<td></td>
<td>&nbsp;未満ならフラグを立てる</td>
</tr>
<tr>
<td>&nbsp;fi ~ clo</td>
<td>&nbsp;fi * es * ce loler</td>
<td></td>
<td>&nbsp;同等ならフラグを立てる</td>
</tr>
<tr>
<td>&nbsp;fi ~ xolo</td>
<td>&nbsp;fi * es * xo loler</td>
<td></td>
<td>&nbsp;以上ならフラグを立てる</td>
</tr>
<tr>
<td>&nbsp;fi ~ llo</td>
<td>&nbsp;fi * es * le loler</td>
<td></td>
<td>&nbsp;超過ならフラグを立てる</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;fen</td>
<td style="width:116px;height:18px">&nbsp;fav es niv e'i</td>
<td style="width:60px">&nbsp;nop<br>
</td>
<td style="width:287px;height:18px">&nbsp;何もしない</td>
</tr>
<tr>
<td style="width:51px;height:18px">&nbsp;qss<span>&nbsp; &nbsp;</span></td>
<td style="width:116px;height:18px">&nbsp;qa'd stevypen snidost</td>
<td style="width:60px">&nbsp;</td>
<td style="width:287px;height:18px">&nbsp;二重移動 (第1オペランドの値を第2オペランドに代入しつつ第2オペランドの古い値を第3オペランドに代入)</td>
</tr>
</tbody>
</table>

<p>さて、6.の最後で『ci指定擬似命令』なるものを導入した以上、基本的にニーモニックはリパライン語で-'i -'cの形となる動詞に由来すべきである。比較命令はともかく。</p>
<ul>
<li>まず、atakesは「-'sを-'iに加算」なので、atakes → atakeses「-'sは-'iを-'cに加算」に変更。</li>
<li>次に、stusniは「(-'sは-'iと-'cを)(計算)かけたものである」なので、紆余曲折の結果latvaves「-'sは-'cに-'iを掛け合わせる」という用語をでっち上げることに。</li>
<li>adalについてもadales「-'sは-'iというANDマスクを-'cにかぶせる」を作成。その勢いでdaliuales「-'sは-'iというXNORマスクを-'cにかぶせる」も。</li>
<li>シフト命令に関しては、命令文にするために副詞を後ろに。結果dtoとdroとなる。</li>
<li>qssも再命名、irzarst ileceonj「同時に移す」略してinjとなる。</li>
<li>nacisもnacises「-'sは-'iを反転させる」、【電算】「-'sは-'iの全ビットを反転させる」を造語</li>
</ul>

<p>ということで、作業が終わった。除算は仕様すら決めていないので後で考えることにして、とりあえず新しくなった表を持ってこよう</p>
<table border="1" bordercolor="#888" cellspacing="0" class="qq">
<tbody>
<tr>
<td>&nbsp;命令</td>
<td>&nbsp;語源</td>
<td>&nbsp;x86</td>
<td>&nbsp;意味</td>
</tr>
<tr>
<td style="width:71px;height:18px">&nbsp;krz</td>
<td style="width:116px;height:18px">&nbsp;krantairzarth</td>
<td style="width:60px">&nbsp;mov</td>
<td style="width:287px;height:18px">&nbsp;複製</td>
</tr>
<tr>
<td>&nbsp;ata</td>
<td>&nbsp;atakeses</td>
<td>&nbsp;add</td>
<td>&nbsp;加算</td>
</tr>
<tr>
<td>&nbsp;nta</td>
<td>&nbsp;ny atakeses</td>
<td>&nbsp;sub</td>
<td>&nbsp;減算</td>
</tr>
<tr>
<td >&nbsp;lat</td>
<td >&nbsp;latvaves</td>
<td >&nbsp;mul</td>
<td >&nbsp;乗算</td>
</tr>
<tr>
<td>&nbsp;(kak)</td>
<td>&nbsp;(kakites)</td>
<td>&nbsp;div</td>
<td>&nbsp;除算</td>
</tr>
<tr>
<td>&nbsp;ada</td>
<td>&nbsp;adales</td>
<td >&nbsp;and</td>
<td>&nbsp;ビット積</td>
</tr>
<tr>
<td>&nbsp;ekc</td>
<td>&nbsp;ekcan</td>
<td>&nbsp;or</td>
<td>&nbsp;ビット和</td>
</tr>
<tr>
<td>&nbsp;nac</td>
<td>&nbsp;nacises</td>
<td>&nbsp;not</td>
<td>&nbsp;ビット反転</td>
</tr>
<tr>
<td>&nbsp;dal</td>
<td>&nbsp;daliuales</td>
<td>&nbsp;xnor</td>
<td>&nbsp;ビットxnor</td>
</tr>
<tr>
<td>&nbsp;dto</td>
<td>&nbsp;dusnij&nbsp;tesnokonj</td>
<td>&nbsp;shr</td>
<td>&nbsp;右シフト</td>
</tr>
<tr>
<td>&nbsp;dro</td>
<td>&nbsp;dusnij restutonj</td>
<td>&nbsp;shl</td>
<td>&nbsp;左シフト</td>
</tr>
<tr>
<td>&nbsp;malkrz</td>
<td>&nbsp;mal krantairzarth</td>
<td>
</td>
<td>&nbsp;フラグが立っているときのみ複製する
</td>
</tr>
<tr>
<td>&nbsp;fi ~ xtlo</td>
<td>&nbsp;fi * es * xut loler</td>
<td></td>
<td>&nbsp;以下ならフラグを立てる</td>
</tr>
<tr>
<td>&nbsp;fi ~ xylo</td>
<td>&nbsp;fi * es * xy loler</td>
<td></td>
<td>&nbsp;未満ならフラグを立てる</td>
</tr>
<tr>
<td>&nbsp;fi ~ clo</td>
<td>&nbsp;fi * es * ce loler</td>
<td></td>
<td>&nbsp;同等ならフラグを立てる</td>
</tr>
<tr>
<td>&nbsp;fi ~ xolo</td>
<td>&nbsp;fi * es * xo loler</td>
<td></td>
<td>&nbsp;以上ならフラグを立てる</td>
</tr>
<tr>
<td>&nbsp;fi ~ llo</td>
<td>&nbsp;fi * es * le loler</td>
<td></td>
<td>&nbsp;超過ならフラグを立てる</td>
</tr>
<tr>
<td>&nbsp;fen</td>
<td>&nbsp;fav es niv e'i</td>
<td>&nbsp;nop<br>
</td>
<td>&nbsp;何もしない</td>
</tr>
<tr>
<td>&nbsp;inj<span>&nbsp;&nbsp;</span></td>
<td>&nbsp;irzarst ileceonj</td>
<td>&nbsp;</td>
<td style="width:287px;height:18px">&nbsp;二重移動 (第1オペランドの値を第2オペランドに代入しつつ第2オペランドの古い値を第3オペランドに代入)</td>
</tr>
</tbody>
</table>

<p>いぇーい。</p>

<h2>10. 整理</h2>

<h3>10-1. 細かい追加事項</h3>
<ul>
<li>アーキテクチャ名は「2003'd ferlesyl」(2003処理器)となった。<a href="https://jurliyuuri.slack.com/archives/C6QL0DKV4/p1504023443000051">出典1</a> <a href="https://twitter.com/hsjoihs/status/903265422362869760">出典2</a></li>
<li>「<a href="https://jurliyuuri.slack.com/archives/C6QL0DKV4/p1504285915000437">マルウェアの歴史欲しいよね</a>、<a href="https://jurliyuuri.slack.com/archives/C6QL0DKV4/p1504285923000525">コンピューターセキュリティ史</a>。」って話が出た。実際メモリ保護機構とかに絡んでくるはずではある。</li>
<li>OSを開発するグループ名が<a href="http://www.jurliyuuri.info/wiki/%E9%80%A3%E9%82%A6%E6%83%85%E5%A0%B1%E5%87%A6%E7%90%86%E7%A0%94%E7%A9%B6%E6%89%80">連邦情報処理研究所</a>に決まりました</li>
</ul>

<h3>10-2. ソースコード分離</h2>
<p>いちいちソースコードを掲載するのも紙面を圧迫しそうなので、ファイルを分離して管理することにした。まずはもともと分離してあった<a href="./qsort.jurli.html">quicksort</a>から。qssをinjに書き換えて、フォントをjietodenにするのも忘れずに。</p>
<p>うーん、やはり角かっこを滅ぼしたいよなぁ</p>
<p>さて、次はフィボナッチを整理するか。とはいえ初期から色々変更点が溜まっているが大丈夫だろうか</p>

<h3>10-3. 課題</h3>
<p>未解決のを列挙していこう。さらに新規に見つかったやつも。</p>
<ul>
<li>角かっこを滅ぼさねば</li>
<li>色んな名前空間が衝突しているぞ。ラベルとニーモニックと関数名とレジスタ名と。</li>
<li>負数ってリパライン語圏でどう表記するの？</li>
</ul>

<h3>10-4. マニュアル分離</h3>
<p>レジスタ一覧とニーモニック一覧が欲しいと言われたので、<a href="settings.html">作った。</a></p>

<h3>10-5. ソースコード分離part2</h2>
<p>ソースコードのフォントを切り替えられる設定にした。あと、とりあえず<a href="fib_non_recursive.jurli.html">非再帰フィボナッチ</a>と<a href="fib_recursive.jurli.html">再帰フィボナッチ</a>のソースコードを独立ファイルとして公開。</p>

<h3>10-6. 課題解決案</h3>
<p><a href="#nta">nta fistir'c 即値'iはata fistir'c (-即値)'iに翻訳される</a>という設定を過去に作ったが、負値の書式がまだ決まらんので<a href="https://twitter.com/sosoBOTpi/status/904028605277102080">アセンブリ言語としてはnta fistir'c 即値'iを許容することとした</a>。ということでソースコードを編集だ。あと、めんどいので<a href="settings.html#dontuse">現状では負数のリテラルは使用しないことに決めた</a>。</p>

<h2>11. 進捗</h2>
<h3>11-1. part1</h3>
<p>S.YやFafs falira sashimiと<a href="pointer_and_label.txt">対談</a>して進捗が出た。</p>
<table border="1" cellpadding="5">
<thead><tr><td>旧構文</td><td>新構文</td><td>役割</td></tr></thead>
<tbody><tr><td><u>ラベル名</u><code>:</code></td><td><code>l' </code><u>ラベル名</u>（後ろから修飾）<br><code>nll </code><u>ラベル名</u>（前から修飾）<br></td><td>ラベル名を定義する</td></tr>
<tr><td><code>[</code><u>レジスタ名</u><code>]</code></td><td><u>レジスタ名</u><code>@</code></td><td>レジスタに入っている番地のメモリを表す。</td></tr><tr><td><code>[</code><u>レジスタ名</u><code> + </code><u>定数</u><code>]</code></td><td><u>レジスタ名</u><code> + </code><u>定数</u><code>@</code></td><td>レジスタに入っている番地に定数を足した番地のメモリを表す。</td></tr>
<tr><td><code>[</code><u>レジスタ名</u><code> + </code><u>レジスタ名</u><code>]</code></td><td><u>レジスタ名</u><code> + </code><u>レジスタ名</u><code>@</code></td><td>2つのレジスタに入っている数値を足した番地のメモリを表す。</td></tr>
</tbody></table>
<p>なお、ここで<code>@</code>で転写されている記号はリパライン語では「ioの合字記号」に対応する。Fafs falira sashimiの「<a href="pointer_and_label.txt">理語的には非文的だけど、アセンブリとしてはできるだけ自然言語に近づいてていい感じな気はする</a>」という発言が決定打となり、採用されることとなった。</p>
<p>ラベル名については、リパライン語に既にあるla lexを使うのが「<a href="pointer_and_label.txt">エモい</a>」とのことだったので採用することとした。問題はla lexをどう表現するかで、「llxのほうが統一的」という意見が出たものの、統一性がないほうがかえってラベルを追いやすいということで<code>l'</code>が採用された。</p>
<p>なお、la lexは前の文を指すので、x86とは違ってラベルは文の後ろから指定する。となると関数を表すためにラベルを導入したときにラベル定義が関数定義の2行目に出てきてしまいよろしくない。ということで逆向きを表すny la lexも導入することにした。<code>nl'</code>を提案したものの、「ny la lexの詩語での省略形がny l' l'/nyll/であるから<code>nll</code>のほうが想起されやすい」ということなので<code>nll</code>に決まった。</p>

<p>とりあえず<a href="settings.html">設定一覧</a>と<a href="fib_non_recursive.jurli.html">非再帰フィボナッチ</a>と<a href="fib_recursive.jurli.html">再帰フィボナッチ</a>と<a href="./qsort.jurli.html">quicksort</a>を改定。</p>

<h3>11-2. part2</h3>
<p><code>::'c'i</code>を<code>'c'i</code>に改定することにした。ということでサンプルと設定集の修正をした。これで一応確定。あと、インデントが要らない気がしてきたので削除。</p>

<h2>12. 修正</h2>
<h3>12-1. バグ修正</h3>
<p>関数からreturnするときの処理に<a href="https://twitter.com/sosoBOTpi/status/904765453272195072">バグがある</a>ことが発覚した。問題箇所を以下に掲載する。</p>
<div class="box" style="border-color: red">
<p>returnする</p>
<pre>
	'c'i
	krz xx f5@	<span class="comment">; リターンアドレスに飛んで</span>
	ata f5 4	<span class="comment">; スタックからリターンアドレスを削除</span>
</pre>
</div>
<p>問題なのは、<code>krz f5@ xx</code>した時点でリターンアドレスに飛んでいるので、その次の行<code>ata f5 4</code>が実行されず、スタックからリターンアドレスを削除できないことである。</p>
<p>ということで、この際呼び出し規約を変更し、「リターンアドレスの分のスタック掃除も呼び出し側の仕事」という仕様にすることにした。</p>

<p>それに従い、<a href="fib_non_recursive.jurli.html">非再帰フィボナッチ</a>をとりあえず修正した。ついでに手動でウォークスルーを行い、おそらくバグっていないであろうことを確認した。</p>

<p><a href="fib_recursive.jurli.html">再帰フィボナッチ</a>も修正した。しかし、修正最中に、呼び出し規約の新たな変更案が思いついたのである。</p>
<p>現状を見てみよう。</p>
<div class="box">
<p>関数funcを呼び出す</p>
<pre>
	'c'i
	nta f5 4	<span class="comment">; スタックを準備</span>
	inj f5@ xx func	<span class="comment">; リターンアドレスを積んで、同一命令で関数のアドレスにジャンプ</span>
	ata f5 4	<span class="comment">; スタックからリターンアドレスを削除する</span>
</pre>
</div>

<p>この<code>nta f5 4</code>と<code>ata f5 4</code>のペア、無駄では？<code>inj f5-4@ xx func</code>と書きたい。</p>
<p>ただ、まだマイナスがないので改定するにしてもまた今度である。</p>

<p>さて、<a href="./qsort.jurli.html">quicksort</a>も改定した。ウォークスルーはしていないが、多分合っていると信じたい。</p>

<h3>12-2. その他</h3>
<p>スタックの伸長方向はアドレスの減少する向きであることを記載した。この仕様、もともと何も考えずにダイスロールで決めた仕様だったけど、よく考えてみると<code>[f5+20]</code>とかのことを考えるとこっちの方が自然だよなぁ</p>

<h2>13. 課題</h2>
<p><a href="unambiguously_parsable.txt">現状の仕様だと、ラベル名と命令名が衝突しても弊害が発生しないが、ラベル名とレジスタ名の衝突は起きうる。将来的に命令が増えても互換性は保たれるが、レジスタが増えるとそうはいかなくなる</a>という課題がありますな。さてどうしよう。</p>
<ol>
	<li>バージョン情報を先頭に指定して、それに応じて読み換える</li>
	<li>ラベル名をなんか修飾する（←でも構文もう変えないって宣言したやん）</li>
	<li>初期の段階ではこの問題に気づかないので対処がなされない</li>
</ol>

<p>よし、3で行くか。</p>
<p>冷静に考えると、ラベル名を「参照」するときはともかく、ラベル名を「定義」するときにはレジスタ名と衝突していればエラー検出はできるので、バージョンが上がってもコンパイルできなくなるだけでこっそり挙動が書き換わることはないはず。じゃあええやん（いいとは言っていない）</p>

<p>まあ、これぐらい欠陥があったほうが「黎明期」っぽくてponaだよね。うんうん。黎明期は任意のものがmalbonaなので。<a href="https://en.wikipedia.org/wiki/RANDU">RANDU</a>とか<a href="https://en.wikipedia.org/wiki/Uncontrolled_format_string">printfとその%n</a>とか。</p>

<p>ということで、この課題については「修正しない」という方針で。</p>

</body>
</html>
